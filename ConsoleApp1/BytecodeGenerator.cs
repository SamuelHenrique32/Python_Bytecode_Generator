using Analyzer;
using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection.Emit;
using System.Threading;

namespace Analyzer
{
    internal class BytecodeGenerator
    {
        public string filePath { get; set; }

        public List<Token> lexicalTokens = new List<Token>();

        // Stores the variables
        //public HashSet<Symbol> symbolsTable = new HashSet<Symbol>(); 
        public List<Symbol> symbolsTable = new List<Symbol>();

        public List<BytecodeRegister> bytecodeRegisters = new List<BytecodeRegister>();

        public Boolean lexicAnalyzed = false;

        public Boolean syntacticAnalyzed = false;

        public Boolean correctSyntax;

        public Boolean currentIDAlreadyInSymbolsTable = false;

        public int currentLineInFile = 0;

        public int currentLineInGeneratedBytecode = 0;

        public int currentOffset = 0;

        //--------------------------------------------------------------------------------------
        // Operations
        public Boolean operationAssignmentInProgress = false;

        public List<Operation> operationsInCurrentLine = new List<Operation>();

        //--------------------------------------------------------------------------------------

        //--------------------------------------------------------------------------------------
        // Operators counter
        public int addOperatorCounter = 0;

        public int subtractionOperatorCounter = 0;

        public int multiplicationOperatorCounter = 0;

        public int divOperatorCounter = 0;

        public int reducedAddOperatorCounter = 0;

        public int reducedSubtractionOperatorCounter = 0;

        public int reducedMultiplicationOperatorCounter = 0;

        public int reducedDivOperatorCounter = 0;

        public int equalOperatorCounter = 0;

        public int difOperatorCounter = 0;

        public int lessThanOperatorCounter = 0;

        public int biggerThanOperatorCounter = 0;

        public int attribuitionOperatorCounter = 0;

        //--------------------------------------------------------------------------------------

        public BytecodeGenerator()
        {
        }

        public Boolean verifyIfSymbolsExistsInTable(Token token)
        {
            for (int i = 0; i < symbolsTable.Count; i++)
            {
                if (symbolsTable[i].symbol.ToString().Equals(token.valor))
                {
                    return true;
                }
            }

            return false;
        }

        public void updateSymbolsTable(Token token)
        {
            for (int i = 0; i < symbolsTable.Count; i++)
            {
                // Add line and column of the current element
                if (symbolsTable[i].symbol.ToString().Equals(token.valor))
                {
                    symbolsTable[i].lines.Add(token.linha);

                    symbolsTable[i].columns.Add(token.coluna);

                    break;
                }
            }
        }

        public void verifyTkId(Token token)
        {
            // Add first element of the table
            if (symbolsTable.Count == 0)
            {
                //Console.WriteLine("\nAdding first symbol\n");

                // Creates symbol
                Symbol symbolToAdd = new Symbol();
                symbolToAdd.symbol = token.valor;
                symbolToAdd.lines.Add(token.linha);
                symbolToAdd.columns.Add(token.coluna);

                // Add to table of symbols
                symbolsTable.Add(symbolToAdd);

                //symbolToString(symbolToAdd);

                currentIDAlreadyInSymbolsTable = false;

                // Add to generated bytecode
            }
            else
            {
                // Verify if already exists in symbolsTable
                if (verifyIfSymbolsExistsInTable(token))
                {
                    //Console.WriteLine("Symbol '" + token.valor + "' already exists in symbols table");

                    updateSymbolsTable(token);

                    currentIDAlreadyInSymbolsTable = true;
                }
                else
                {
                    //Console.WriteLine("Adding symbol '" + token.valor + "'\n");

                    // Creates symbol
                    Symbol symbolToAdd = new Symbol();
                    symbolToAdd.symbol = token.valor;
                    symbolToAdd.lines.Add(token.linha);
                    symbolToAdd.columns.Add(token.coluna);

                    // Add to table of symbols
                    symbolsTable.Add(symbolToAdd);

                    currentIDAlreadyInSymbolsTable = false;
                }
            }
        }

        public void handleTkId(Token tk, int currentPos)
        {
            Token tkProx = getNextToken(currentPos);

            switch (tkProx.tipo)
            {
                case TipoTk.TkAtrib:

                    operationAssignmentInProgress = true;

                    //--------------------------------------------------------------------------------------
                    // Prepares LOAD_CONST
                    BytecodeRegister bytecodeRegisterCurrentToken = new BytecodeRegister();
                    
                    bytecodeRegisterCurrentToken.lineInGeneratedBytecode = currentLineInGeneratedBytecode++;
                    
                    bytecodeRegisterCurrentToken.lineInFile = tk.linha;
                    
                    bytecodeRegisterCurrentToken.offset = currentOffset;

                    this.currentOffset += 2;

                    bytecodeRegisterCurrentToken.opCode = (int) OpCode.LOAD_CONST;
                    
                    // TODO
                    bytecodeRegisterCurrentToken.stackPos = 0;

                    bytecodeRegisters.Add(bytecodeRegisterCurrentToken);
                    //--------------------------------------------------------------------------------------

                    //--------------------------------------------------------------------------------------
                    // Prepares STORE_FAST
                    BytecodeRegister bytecodeRegisterNextToken = new BytecodeRegister();

                    bytecodeRegisterNextToken.preview = ("(" + tk.valor + ")");

                    bytecodeRegisters.Add(bytecodeRegisterNextToken);
                    //--------------------------------------------------------------------------------------

                    break;
            }
        }

        public void symbolToString(Symbol sym)
        {
            Console.WriteLine("-----------------------------");

            Console.WriteLine("Symbol: " + sym.symbol + "\n");

            Console.WriteLine("Lines:");

            foreach (int line in sym.lines)
            {
                Console.WriteLine(line + "\n");
            }

            Console.WriteLine("Columns:");

            foreach (int column in sym.columns)
            {
                Console.WriteLine(column + "");
            }

            Console.WriteLine("-----------------------------\n");
        }

        public Token getNextToken(int currentPos)
        {
            return lexicalTokens[currentPos + 1];
        }

        public void generateBytecode()
        {
            int currentLexeme = 0;

            currentIDAlreadyInSymbolsTable = false;

            // Foreach lexeme identified by lexicon
            foreach (var t in lexicalTokens)
            {
                //Console.WriteLine("Token: " + t.tipo.ToString() + "\tLexema: " + t.valor + "\t Linha: " + t.linha + "\t Coluna: " + t.coluna);

                if(t.linha != currentLineInFile)
                {
                    currentLineInFile = t.linha;

                    resetCountOperators();

                    countOperators(currentLineInFile);
                }

                switch (t.tipo)
                {
                    case TipoTk.TkId:

                        //Console.WriteLine("\nEh id\n");

                        verifyTkId(t);

                        //handleTkId(t, currentLexeme);

                    break;

                    case TipoTk.TkAtrib:

                        if (operationAssignmentInProgress)
                        {
                            // For now, do nothing
                        }

                    break;

                    case TipoTk.TkNumconst:

                        /*if (operationAssignmentInProgress)
                        {
                            operationAssignmentInProgress = false;

                            bytecodeRegisters[currentLineInGeneratedBytecode].lineInGeneratedBytecode = currentLineInGeneratedBytecode;

                            bytecodeRegisters[currentLineInGeneratedBytecode].lineInFile = t.linha;

                            bytecodeRegisters[currentLineInGeneratedBytecode].offset = currentOffset;

                            this.currentOffset += 2;

                            bytecodeRegisters[currentLineInGeneratedBytecode].opCode = (int)OpCode.STORE_FAST;

                            // TODO
                            bytecodeRegisters[currentLineInGeneratedBytecode].stackPos = 0;

                            bytecodeRegisters[currentLineInGeneratedBytecode - 1].preview = ("(" + t.valor + ")");

                            this.currentLineInGeneratedBytecode++;
                        }*/

                    break;
                }                
            }
            printGeneratedBytecode();
        }

        public void printGeneratedBytecode()
        {
            int lastPrintedLine = 0;

            Console.WriteLine("Bytecode Gerado:");

            foreach (BytecodeRegister bytecodeRegister in bytecodeRegisters)
            {
                if (bytecodeRegister.lineInFile != lastPrintedLine)
                {
                    Console.Write("\n" + bytecodeRegister.lineInFile + "\t");

                    lastPrintedLine = bytecodeRegister.lineInFile;
                }
                else
                {
                    Console.Write("\t");
                }

                Console.Write(bytecodeRegister.offset + "  ");

                Console.Write(getOpCodeDescription(bytecodeRegister.opCode) + "\t\t");

                // TODO
                Console.Write(bytecodeRegister.stackPos + "  ");

                Console.WriteLine(bytecodeRegister.preview);
            }
        }

        public String getOpCodeDescription(int opCode)
        {
            switch (opCode)
            {
                case 0:
                    return "LOAD_CONST";
                break;

                case 1:
                    return "STORE_FAST";
                break;
            }

            return "";
        }

        public void countOperators(int currentLine)
        {
            for(int i=0; i< lexicalTokens.Count; i++)
            {
                if(lexicalTokens[i].linha == currentLine)
                {
                    switch (lexicalTokens[i].tipo)
                    {
                        case TipoTk.TkMais:
                            addOperatorCounter++;
                        break;

                        case TipoTk.TkMenos:
                            subtractionOperatorCounter++;
                        break;

                        case TipoTk.TkMultiplicaco:
                            multiplicationOperatorCounter++;
                        break;

                        case TipoTk.TkDivisao:
                            divOperatorCounter++;
                        break;

                        case TipoTk.TkMaisIgual:
                            reducedAddOperatorCounter++;
                        break;

                        case TipoTk.TkMenosIgual:
                            reducedSubtractionOperatorCounter++;
                        break;

                        case TipoTk.TkMulIgual:
                            reducedMultiplicationOperatorCounter++;
                        break;

                        case TipoTk.TkDivIgual:
                            reducedDivOperatorCounter++;
                        break;

                        case TipoTk.TkIgual:
                            equalOperatorCounter++;
                        break;

                        case TipoTk.TkDiferente:
                            difOperatorCounter++;
                        break;

                        case TipoTk.TkMenor:
                            lessThanOperatorCounter++;
                        break;

                        case TipoTk.TkMaior:
                            biggerThanOperatorCounter++;
                        break;

                        case TipoTk.TkAtrib:
                            attribuitionOperatorCounter++;
                        break;
                    }
                }
            }
        }

        public void resetCountOperators()
        {
            addOperatorCounter = 0;

            subtractionOperatorCounter = 0;

            multiplicationOperatorCounter = 0;

            divOperatorCounter = 0;

            reducedAddOperatorCounter = 0;

            reducedSubtractionOperatorCounter = 0;

            reducedMultiplicationOperatorCounter = 0;

            reducedDivOperatorCounter = 0;

            equalOperatorCounter = 0;

            difOperatorCounter = 0;

            lessThanOperatorCounter = 0;

            biggerThanOperatorCounter = 0;

            attribuitionOperatorCounter = 0;
        }
    }    
}